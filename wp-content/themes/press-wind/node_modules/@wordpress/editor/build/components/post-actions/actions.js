"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.usePostActions = usePostActions;
var _data = require("@wordpress/data");
var _element = require("@wordpress/element");
var _store = require("../../store");
var _lockUnlock = require("../../lock-unlock");
var _jsxRuntime = require("react/jsx-runtime");
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

function usePostActions({
  postType,
  onActionPerformed,
  context
}) {
  const {
    defaultActions
  } = (0, _data.useSelect)(select => {
    const {
      getEntityActions
    } = (0, _lockUnlock.unlock)(select(_store.store));
    return {
      defaultActions: getEntityActions('postType', postType)
    };
  }, [postType]);
  const {
    registerPostTypeActions
  } = (0, _lockUnlock.unlock)((0, _data.useDispatch)(_store.store));
  (0, _element.useEffect)(() => {
    registerPostTypeActions(postType);
  }, [registerPostTypeActions, postType]);
  return (0, _element.useMemo)(() => {
    // Filter actions based on provided context. If not provided
    // all actions are returned. We'll have a single entry for getting the actions
    // and the consumer should provide the context to filter the actions, if needed.
    // Actions should also provide the `context` they support, if it's specific, to
    // compare with the provided context to get all the actions.
    // Right now the only supported context is `list`.
    const actions = defaultActions.filter(action => {
      if (!action.context) {
        return true;
      }
      return action.context === context;
    });
    if (onActionPerformed) {
      for (let i = 0; i < actions.length; ++i) {
        if (actions[i].callback) {
          const existingCallback = actions[i].callback;
          actions[i] = {
            ...actions[i],
            callback: (items, argsObject) => {
              existingCallback(items, {
                ...argsObject,
                onActionPerformed: _items => {
                  if (argsObject?.onActionPerformed) {
                    argsObject.onActionPerformed(_items);
                  }
                  onActionPerformed(actions[i].id, _items);
                }
              });
            }
          };
        }
        if (actions[i].RenderModal) {
          const ExistingRenderModal = actions[i].RenderModal;
          actions[i] = {
            ...actions[i],
            RenderModal: props => {
              return /*#__PURE__*/(0, _jsxRuntime.jsx)(ExistingRenderModal, {
                ...props,
                onActionPerformed: _items => {
                  if (props.onActionPerformed) {
                    props.onActionPerformed(_items);
                  }
                  onActionPerformed(actions[i].id, _items);
                }
              });
            }
          };
        }
      }
    }
    return actions;
  }, [defaultActions, onActionPerformed, context]);
}
//# sourceMappingURL=actions.js.map