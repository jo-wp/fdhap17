"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.PrivateBlockPopover = void 0;
var _clsx = _interopRequireDefault(require("clsx"));
var _compose = require("@wordpress/compose");
var _components = require("@wordpress/components");
var _data = require("@wordpress/data");
var _element = require("@wordpress/element");
var _useBlockRefs = require("../block-list/use-block-props/use-block-refs");
var _usePopoverScroll = _interopRequireDefault(require("./use-popover-scroll"));
var _dom = require("../../utils/dom");
var _store = require("../../store");
var _lockUnlock = require("../../lock-unlock");
var _jsxRuntime = require("react/jsx-runtime");
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

const MAX_POPOVER_RECOMPUTE_COUNTER = Number.MAX_SAFE_INTEGER;
function BlockPopover({
  clientId,
  bottomClientId,
  children,
  __unstablePopoverSlot,
  __unstableContentRef,
  shift = true,
  ...props
}, ref) {
  const selectedElement = (0, _useBlockRefs.useBlockElement)(clientId);
  const lastSelectedElement = (0, _useBlockRefs.useBlockElement)(bottomClientId !== null && bottomClientId !== void 0 ? bottomClientId : clientId);
  const mergedRefs = (0, _compose.useMergeRefs)([ref, (0, _usePopoverScroll.default)(__unstableContentRef)]);
  const [popoverDimensionsRecomputeCounter, forceRecomputePopoverDimensions] = (0, _element.useReducer)(
  // Module is there to make sure that the counter doesn't overflow.
  s => (s + 1) % MAX_POPOVER_RECOMPUTE_COUNTER, 0);

  // When blocks are moved up/down, they are animated to their new position by
  // updating the `transform` property manually (i.e. without using CSS
  // transitions or animations). The animation, which can also scroll the block
  // editor, can sometimes cause the position of the Popover to get out of sync.
  // A MutationObserver is therefore used to make sure that changes to the
  // selectedElement's attribute (i.e. `transform`) can be tracked and used to
  // trigger the Popover to rerender.
  (0, _element.useLayoutEffect)(() => {
    if (!selectedElement) {
      return;
    }
    const observer = new window.MutationObserver(forceRecomputePopoverDimensions);
    observer.observe(selectedElement, {
      attributes: true
    });
    return () => {
      observer.disconnect();
    };
  }, [selectedElement]);
  const {
    isZoomOut,
    parentSectionBlock,
    isSectionSelected
  } = (0, _data.useSelect)(select => {
    var _getParentSectionBloc;
    const {
      isZoomOut: isZoomOutSelector,
      getSectionRootClientId,
      getParentSectionBlock,
      getBlockOrder
    } = (0, _lockUnlock.unlock)(select(_store.store));
    return {
      isZoomOut: isZoomOutSelector(),
      parentSectionBlock: (_getParentSectionBloc = getParentSectionBlock(clientId)) !== null && _getParentSectionBloc !== void 0 ? _getParentSectionBloc : clientId,
      isSectionSelected: getBlockOrder(getSectionRootClientId()).includes(clientId)
    };
  }, [clientId]);

  // This element is used to position the zoom out view vertical toolbar
  // correctly, relative to the selected section.
  const parentSectionElement = (0, _useBlockRefs.useBlockElement)(parentSectionBlock);
  const popoverAnchor = (0, _element.useMemo)(() => {
    if (
    // popoverDimensionsRecomputeCounter is by definition always equal or greater
    // than 0. This check is only there to satisfy the correctness of the
    // exhaustive-deps rule for the `useMemo` hook.
    popoverDimensionsRecomputeCounter < 0 || isZoomOut && !parentSectionElement || !selectedElement || bottomClientId && !lastSelectedElement) {
      return undefined;
    }
    return {
      getBoundingClientRect() {
        // The zoom out view has a vertical block toolbar that should always
        // be on the edge of the canvas, aligned to the top of the currently
        // selected section. This condition changes the anchor of the toolbar
        // to the section instead of the block to handle blocks that are
        // not full width and nested blocks to keep section height.
        if (isZoomOut && isSectionSelected) {
          // Compute the height based on the parent section of the
          // selected block, because the selected block may be
          // shorter than the section.
          const canvasElementRect = (0, _dom.getVisibleElementBounds)(__unstableContentRef.current);
          const parentSectionElementRect = (0, _dom.getVisibleElementBounds)(parentSectionElement);
          const anchorHeight = parentSectionElementRect.bottom - parentSectionElementRect.top;

          // Always use the width of the section root element to make sure
          // the toolbar is always on the edge of the canvas.
          const anchorWidth = canvasElementRect.width;
          return new window.DOMRectReadOnly(canvasElementRect.left, parentSectionElementRect.top, anchorWidth, anchorHeight);
        }
        return lastSelectedElement ? (0, _dom.rectUnion)((0, _dom.getVisibleElementBounds)(selectedElement), (0, _dom.getVisibleElementBounds)(lastSelectedElement)) : (0, _dom.getVisibleElementBounds)(selectedElement);
      },
      contextElement: selectedElement
    };
  }, [popoverDimensionsRecomputeCounter, isZoomOut, parentSectionElement, selectedElement, bottomClientId, lastSelectedElement, isSectionSelected, __unstableContentRef]);
  if (!selectedElement || bottomClientId && !lastSelectedElement) {
    return null;
  }
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_components.Popover, {
    ref: mergedRefs,
    animate: false,
    focusOnMount: false,
    anchor: popoverAnchor
    // Render in the old slot if needed for backward compatibility,
    // otherwise render in place (not in the default popover slot).
    ,
    __unstableSlotName: __unstablePopoverSlot,
    inline: !__unstablePopoverSlot,
    placement: "top-start",
    resize: false,
    flip: false,
    shift: shift,
    ...props,
    className: (0, _clsx.default)('block-editor-block-popover', props.className),
    variant: "unstyled",
    children: children
  });
}
const PrivateBlockPopover = exports.PrivateBlockPopover = (0, _element.forwardRef)(BlockPopover);
const PublicBlockPopover = ({
  clientId,
  bottomClientId,
  children,
  ...props
}, ref) => /*#__PURE__*/(0, _jsxRuntime.jsx)(PrivateBlockPopover, {
  ...props,
  bottomClientId: bottomClientId,
  clientId: clientId,
  __unstableContentRef: undefined,
  __unstablePopoverSlot: undefined,
  ref: ref,
  children: children
});

/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/block-popover/README.md
 */
var _default = exports.default = (0, _element.forwardRef)(PublicBlockPopover);
//# sourceMappingURL=index.js.map