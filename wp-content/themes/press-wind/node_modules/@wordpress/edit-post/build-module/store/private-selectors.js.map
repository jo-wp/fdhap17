{"version":3,"names":["createRegistrySelector","store","coreStore","editorStore","getEditedPostTemplateId","select","id","postId","type","postType","slug","getCurrentPost","getEntityRecord","getEntityRecords","canUser","siteSettings","kind","name","undefined","isPostsPage","page_for_posts","getDefaultTemplateId","currentTemplate","getEditedPostAttribute","templateWithSameSlug","per_page","find","template","slugToCheck"],"sources":["@wordpress/edit-post/src/store/private-selectors.js"],"sourcesContent":["/**\n * WordPress dependencies\n */\nimport { createRegistrySelector } from '@wordpress/data';\nimport { store as coreStore } from '@wordpress/core-data';\nimport { store as editorStore } from '@wordpress/editor';\n\nexport const getEditedPostTemplateId = createRegistrySelector(\n\t( select ) => () => {\n\t\tconst {\n\t\t\tid: postId,\n\t\t\ttype: postType,\n\t\t\tslug,\n\t\t} = select( editorStore ).getCurrentPost();\n\t\tconst { getEntityRecord, getEntityRecords, canUser } =\n\t\t\tselect( coreStore );\n\t\tconst siteSettings = canUser( 'read', {\n\t\t\tkind: 'root',\n\t\t\tname: 'site',\n\t\t} )\n\t\t\t? getEntityRecord( 'root', 'site' )\n\t\t\t: undefined;\n\t\t// First check if the current page is set as the posts page.\n\t\tconst isPostsPage = +postId === siteSettings?.page_for_posts;\n\t\tif ( isPostsPage ) {\n\t\t\treturn select( coreStore ).getDefaultTemplateId( { slug: 'home' } );\n\t\t}\n\t\tconst currentTemplate =\n\t\t\tselect( editorStore ).getEditedPostAttribute( 'template' );\n\t\tif ( currentTemplate ) {\n\t\t\tconst templateWithSameSlug = getEntityRecords(\n\t\t\t\t'postType',\n\t\t\t\t'wp_template',\n\t\t\t\t{ per_page: -1 }\n\t\t\t)?.find( ( template ) => template.slug === currentTemplate );\n\t\t\tif ( ! templateWithSameSlug ) {\n\t\t\t\treturn templateWithSameSlug;\n\t\t\t}\n\t\t\treturn templateWithSameSlug.id;\n\t\t}\n\t\tlet slugToCheck;\n\t\t// In `draft` status we might not have a slug available, so we use the `single`\n\t\t// post type templates slug(ex page, single-post, single-product etc..).\n\t\t// Pages do not need the `single` prefix in the slug to be prioritized\n\t\t// through template hierarchy.\n\t\tif ( slug ) {\n\t\t\tslugToCheck =\n\t\t\t\tpostType === 'page'\n\t\t\t\t\t? `${ postType }-${ slug }`\n\t\t\t\t\t: `single-${ postType }-${ slug }`;\n\t\t} else {\n\t\t\tslugToCheck = postType === 'page' ? 'page' : `single-${ postType }`;\n\t\t}\n\n\t\tif ( postType ) {\n\t\t\treturn select( coreStore ).getDefaultTemplateId( {\n\t\t\t\tslug: slugToCheck,\n\t\t\t} );\n\t\t}\n\t}\n);\n"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,sBAAsB,QAAQ,iBAAiB;AACxD,SAASC,KAAK,IAAIC,SAAS,QAAQ,sBAAsB;AACzD,SAASD,KAAK,IAAIE,WAAW,QAAQ,mBAAmB;AAExD,OAAO,MAAMC,uBAAuB,GAAGJ,sBAAsB,CAC1DK,MAAM,IAAM,MAAM;EACnB,MAAM;IACLC,EAAE,EAAEC,MAAM;IACVC,IAAI,EAAEC,QAAQ;IACdC;EACD,CAAC,GAAGL,MAAM,CAAEF,WAAY,CAAC,CAACQ,cAAc,CAAC,CAAC;EAC1C,MAAM;IAAEC,eAAe;IAAEC,gBAAgB;IAAEC;EAAQ,CAAC,GACnDT,MAAM,CAAEH,SAAU,CAAC;EACpB,MAAMa,YAAY,GAAGD,OAAO,CAAE,MAAM,EAAE;IACrCE,IAAI,EAAE,MAAM;IACZC,IAAI,EAAE;EACP,CAAE,CAAC,GACAL,eAAe,CAAE,MAAM,EAAE,MAAO,CAAC,GACjCM,SAAS;EACZ;EACA,MAAMC,WAAW,GAAG,CAACZ,MAAM,KAAKQ,YAAY,EAAEK,cAAc;EAC5D,IAAKD,WAAW,EAAG;IAClB,OAAOd,MAAM,CAAEH,SAAU,CAAC,CAACmB,oBAAoB,CAAE;MAAEX,IAAI,EAAE;IAAO,CAAE,CAAC;EACpE;EACA,MAAMY,eAAe,GACpBjB,MAAM,CAAEF,WAAY,CAAC,CAACoB,sBAAsB,CAAE,UAAW,CAAC;EAC3D,IAAKD,eAAe,EAAG;IACtB,MAAME,oBAAoB,GAAGX,gBAAgB,CAC5C,UAAU,EACV,aAAa,EACb;MAAEY,QAAQ,EAAE,CAAC;IAAE,CAChB,CAAC,EAAEC,IAAI,CAAIC,QAAQ,IAAMA,QAAQ,CAACjB,IAAI,KAAKY,eAAgB,CAAC;IAC5D,IAAK,CAAEE,oBAAoB,EAAG;MAC7B,OAAOA,oBAAoB;IAC5B;IACA,OAAOA,oBAAoB,CAAClB,EAAE;EAC/B;EACA,IAAIsB,WAAW;EACf;EACA;EACA;EACA;EACA,IAAKlB,IAAI,EAAG;IACXkB,WAAW,GACVnB,QAAQ,KAAK,MAAM,GAChB,GAAIA,QAAQ,IAAMC,IAAI,EAAG,GACzB,UAAWD,QAAQ,IAAMC,IAAI,EAAG;EACrC,CAAC,MAAM;IACNkB,WAAW,GAAGnB,QAAQ,KAAK,MAAM,GAAG,MAAM,GAAG,UAAWA,QAAQ,EAAG;EACpE;EAEA,IAAKA,QAAQ,EAAG;IACf,OAAOJ,MAAM,CAAEH,SAAU,CAAC,CAACmB,oBAAoB,CAAE;MAChDX,IAAI,EAAEkB;IACP,CAAE,CAAC;EACJ;AACD,CACD,CAAC","ignoreList":[]}