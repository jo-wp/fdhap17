"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getEditedPostTemplateId = void 0;
var _data = require("@wordpress/data");
var _coreData = require("@wordpress/core-data");
var _editor = require("@wordpress/editor");
/**
 * WordPress dependencies
 */

const getEditedPostTemplateId = exports.getEditedPostTemplateId = (0, _data.createRegistrySelector)(select => () => {
  const {
    id: postId,
    type: postType,
    slug
  } = select(_editor.store).getCurrentPost();
  const {
    getEntityRecord,
    getEntityRecords,
    canUser
  } = select(_coreData.store);
  const siteSettings = canUser('read', {
    kind: 'root',
    name: 'site'
  }) ? getEntityRecord('root', 'site') : undefined;
  // First check if the current page is set as the posts page.
  const isPostsPage = +postId === siteSettings?.page_for_posts;
  if (isPostsPage) {
    return select(_coreData.store).getDefaultTemplateId({
      slug: 'home'
    });
  }
  const currentTemplate = select(_editor.store).getEditedPostAttribute('template');
  if (currentTemplate) {
    const templateWithSameSlug = getEntityRecords('postType', 'wp_template', {
      per_page: -1
    })?.find(template => template.slug === currentTemplate);
    if (!templateWithSameSlug) {
      return templateWithSameSlug;
    }
    return templateWithSameSlug.id;
  }
  let slugToCheck;
  // In `draft` status we might not have a slug available, so we use the `single`
  // post type templates slug(ex page, single-post, single-product etc..).
  // Pages do not need the `single` prefix in the slug to be prioritized
  // through template hierarchy.
  if (slug) {
    slugToCheck = postType === 'page' ? `${postType}-${slug}` : `single-${postType}-${slug}`;
  } else {
    slugToCheck = postType === 'page' ? 'page' : `single-${postType}`;
  }
  if (postType) {
    return select(_coreData.store).getDefaultTemplateId({
      slug: slugToCheck
    });
  }
});
//# sourceMappingURL=private-selectors.js.map