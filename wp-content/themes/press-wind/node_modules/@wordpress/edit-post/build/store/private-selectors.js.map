{"version":3,"names":["_data","require","_coreData","_editor","getEditedPostTemplateId","exports","createRegistrySelector","select","id","postId","type","postType","slug","editorStore","getCurrentPost","getEntityRecord","getEntityRecords","canUser","coreStore","siteSettings","kind","name","undefined","isPostsPage","page_for_posts","getDefaultTemplateId","currentTemplate","getEditedPostAttribute","templateWithSameSlug","per_page","find","template","slugToCheck"],"sources":["@wordpress/edit-post/src/store/private-selectors.js"],"sourcesContent":["/**\n * WordPress dependencies\n */\nimport { createRegistrySelector } from '@wordpress/data';\nimport { store as coreStore } from '@wordpress/core-data';\nimport { store as editorStore } from '@wordpress/editor';\n\nexport const getEditedPostTemplateId = createRegistrySelector(\n\t( select ) => () => {\n\t\tconst {\n\t\t\tid: postId,\n\t\t\ttype: postType,\n\t\t\tslug,\n\t\t} = select( editorStore ).getCurrentPost();\n\t\tconst { getEntityRecord, getEntityRecords, canUser } =\n\t\t\tselect( coreStore );\n\t\tconst siteSettings = canUser( 'read', {\n\t\t\tkind: 'root',\n\t\t\tname: 'site',\n\t\t} )\n\t\t\t? getEntityRecord( 'root', 'site' )\n\t\t\t: undefined;\n\t\t// First check if the current page is set as the posts page.\n\t\tconst isPostsPage = +postId === siteSettings?.page_for_posts;\n\t\tif ( isPostsPage ) {\n\t\t\treturn select( coreStore ).getDefaultTemplateId( { slug: 'home' } );\n\t\t}\n\t\tconst currentTemplate =\n\t\t\tselect( editorStore ).getEditedPostAttribute( 'template' );\n\t\tif ( currentTemplate ) {\n\t\t\tconst templateWithSameSlug = getEntityRecords(\n\t\t\t\t'postType',\n\t\t\t\t'wp_template',\n\t\t\t\t{ per_page: -1 }\n\t\t\t)?.find( ( template ) => template.slug === currentTemplate );\n\t\t\tif ( ! templateWithSameSlug ) {\n\t\t\t\treturn templateWithSameSlug;\n\t\t\t}\n\t\t\treturn templateWithSameSlug.id;\n\t\t}\n\t\tlet slugToCheck;\n\t\t// In `draft` status we might not have a slug available, so we use the `single`\n\t\t// post type templates slug(ex page, single-post, single-product etc..).\n\t\t// Pages do not need the `single` prefix in the slug to be prioritized\n\t\t// through template hierarchy.\n\t\tif ( slug ) {\n\t\t\tslugToCheck =\n\t\t\t\tpostType === 'page'\n\t\t\t\t\t? `${ postType }-${ slug }`\n\t\t\t\t\t: `single-${ postType }-${ slug }`;\n\t\t} else {\n\t\t\tslugToCheck = postType === 'page' ? 'page' : `single-${ postType }`;\n\t\t}\n\n\t\tif ( postType ) {\n\t\t\treturn select( coreStore ).getDefaultTemplateId( {\n\t\t\t\tslug: slugToCheck,\n\t\t\t} );\n\t\t}\n\t}\n);\n"],"mappings":";;;;;;AAGA,IAAAA,KAAA,GAAAC,OAAA;AACA,IAAAC,SAAA,GAAAD,OAAA;AACA,IAAAE,OAAA,GAAAF,OAAA;AALA;AACA;AACA;;AAKO,MAAMG,uBAAuB,GAAAC,OAAA,CAAAD,uBAAA,GAAG,IAAAE,4BAAsB,EAC1DC,MAAM,IAAM,MAAM;EACnB,MAAM;IACLC,EAAE,EAAEC,MAAM;IACVC,IAAI,EAAEC,QAAQ;IACdC;EACD,CAAC,GAAGL,MAAM,CAAEM,aAAY,CAAC,CAACC,cAAc,CAAC,CAAC;EAC1C,MAAM;IAAEC,eAAe;IAAEC,gBAAgB;IAAEC;EAAQ,CAAC,GACnDV,MAAM,CAAEW,eAAU,CAAC;EACpB,MAAMC,YAAY,GAAGF,OAAO,CAAE,MAAM,EAAE;IACrCG,IAAI,EAAE,MAAM;IACZC,IAAI,EAAE;EACP,CAAE,CAAC,GACAN,eAAe,CAAE,MAAM,EAAE,MAAO,CAAC,GACjCO,SAAS;EACZ;EACA,MAAMC,WAAW,GAAG,CAACd,MAAM,KAAKU,YAAY,EAAEK,cAAc;EAC5D,IAAKD,WAAW,EAAG;IAClB,OAAOhB,MAAM,CAAEW,eAAU,CAAC,CAACO,oBAAoB,CAAE;MAAEb,IAAI,EAAE;IAAO,CAAE,CAAC;EACpE;EACA,MAAMc,eAAe,GACpBnB,MAAM,CAAEM,aAAY,CAAC,CAACc,sBAAsB,CAAE,UAAW,CAAC;EAC3D,IAAKD,eAAe,EAAG;IACtB,MAAME,oBAAoB,GAAGZ,gBAAgB,CAC5C,UAAU,EACV,aAAa,EACb;MAAEa,QAAQ,EAAE,CAAC;IAAE,CAChB,CAAC,EAAEC,IAAI,CAAIC,QAAQ,IAAMA,QAAQ,CAACnB,IAAI,KAAKc,eAAgB,CAAC;IAC5D,IAAK,CAAEE,oBAAoB,EAAG;MAC7B,OAAOA,oBAAoB;IAC5B;IACA,OAAOA,oBAAoB,CAACpB,EAAE;EAC/B;EACA,IAAIwB,WAAW;EACf;EACA;EACA;EACA;EACA,IAAKpB,IAAI,EAAG;IACXoB,WAAW,GACVrB,QAAQ,KAAK,MAAM,GAChB,GAAIA,QAAQ,IAAMC,IAAI,EAAG,GACzB,UAAWD,QAAQ,IAAMC,IAAI,EAAG;EACrC,CAAC,MAAM;IACNoB,WAAW,GAAGrB,QAAQ,KAAK,MAAM,GAAG,MAAM,GAAG,UAAWA,QAAQ,EAAG;EACpE;EAEA,IAAKA,QAAQ,EAAG;IACf,OAAOJ,MAAM,CAAEW,eAAU,CAAC,CAACO,oBAAoB,CAAE;MAChDb,IAAI,EAAEoB;IACP,CAAE,CAAC;EACJ;AACD,CACD,CAAC","ignoreList":[]}