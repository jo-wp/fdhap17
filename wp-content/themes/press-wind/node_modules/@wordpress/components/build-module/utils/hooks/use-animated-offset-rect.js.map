{"version":3,"names":["useEvent","useLayoutEffect","useOnValueUpdate","useAnimatedOffsetRect","container","rect","prefix","dataAttribute","transitionEndFilter","setProperties","Object","keys","forEach","property","style","setProperty","String","element","previousValue","setAttribute","onTransitionEnd","event","removeAttribute","addEventListener","removeEventListener"],"sources":["@wordpress/components/src/utils/hooks/use-animated-offset-rect.ts"],"sourcesContent":["/* eslint-disable jsdoc/require-param */\n\n/**\n * WordPress dependencies\n */\nimport { useEvent } from '@wordpress/compose';\nimport { useLayoutEffect } from '@wordpress/element';\n/**\n * Internal dependencies\n */\nimport type { ElementOffsetRect } from '../element-rect';\nimport { useOnValueUpdate } from './use-on-value-update';\n\n/**\n * A utility used to animate something in a container component based on the \"offset\n * rect\" (position relative to the container and size) of a subelement. For example,\n * this is useful to render an indicator for the selected option of a component, and\n * to animate it when the selected option changes.\n *\n * Takes in a container element and the up-to-date \"offset rect\" of the target\n * subelement, obtained with `useTrackElementOffsetRect`. Then it does the following:\n *\n * - Adds CSS variables with rect information to the container, so that the indicator\n *   can be rendered and animated with them. These are kept up-to-date, enabling CSS\n *   transitions on change.\n * - Sets an attribute (`data-subelement-animated` by default) when the tracked\n *   element changes, so that the target (e.g. the indicator) can be animated to its\n *   new size and position.\n * - Removes the attribute when the animation is done.\n *\n * The need for the attribute is due to the fact that the rect might update in\n * situations other than when the tracked element changes, e.g. the tracked element\n * might be resized. In such cases, there is no need to animate the indicator, and\n * the change in size or position of the indicator needs to be reflected immediately.\n */\nexport function useAnimatedOffsetRect(\n\t/**\n\t * The container element.\n\t */\n\tcontainer: HTMLElement | undefined,\n\t/**\n\t * The rect of the tracked element.\n\t */\n\trect: ElementOffsetRect,\n\t{\n\t\tprefix = 'subelement',\n\t\tdataAttribute = `${ prefix }-animated`,\n\t\ttransitionEndFilter = () => true,\n\t}: {\n\t\t/**\n\t\t * The prefix used for the CSS variables, e.g. if `prefix` is `selected`, the\n\t\t * CSS variables will be `--selected-top`, `--selected-left`, etc.\n\t\t * @default 'subelement'\n\t\t */\n\t\tprefix?: string;\n\t\t/**\n\t\t * The name of the data attribute used to indicate that the animation is in\n\t\t * progress. The `data-` prefix is added automatically.\n\t\t *\n\t\t * For example, if `dataAttribute` is `indicator-animated`, the attribute will\n\t\t * be `data-indicator-animated`.\n\t\t * @default `${ prefix }-animated`\n\t\t */\n\t\tdataAttribute?: string;\n\t\t/**\n\t\t * A function that is called with the transition event and returns a boolean\n\t\t * indicating whether the animation should be stopped. The default is a function\n\t\t * that always returns `true`.\n\t\t *\n\t\t * For example, if the animated element is the `::before` pseudo-element, the\n\t\t * function can be written as `( event ) => event.pseudoElement === '::before'`.\n\t\t * @default () => true\n\t\t */\n\t\ttransitionEndFilter?: ( event: TransitionEvent ) => boolean;\n\t} = {}\n) {\n\tconst setProperties = useEvent( () => {\n\t\t( Object.keys( rect ) as Array< keyof typeof rect > ).forEach(\n\t\t\t( property ) =>\n\t\t\t\tproperty !== 'element' &&\n\t\t\t\tcontainer?.style.setProperty(\n\t\t\t\t\t`--${ prefix }-${ property }`,\n\t\t\t\t\tString( rect[ property ] )\n\t\t\t\t)\n\t\t);\n\t} );\n\tuseLayoutEffect( () => {\n\t\tsetProperties();\n\t}, [ rect, setProperties ] );\n\tuseOnValueUpdate( rect.element, ( { previousValue } ) => {\n\t\t// Only enable the animation when moving from one element to another.\n\t\tif ( rect.element && previousValue ) {\n\t\t\tcontainer?.setAttribute( `data-${ dataAttribute }`, '' );\n\t\t}\n\t} );\n\tuseLayoutEffect( () => {\n\t\tfunction onTransitionEnd( event: TransitionEvent ) {\n\t\t\tif ( transitionEndFilter( event ) ) {\n\t\t\t\tcontainer?.removeAttribute( `data-${ dataAttribute }` );\n\t\t\t}\n\t\t}\n\t\tcontainer?.addEventListener( 'transitionend', onTransitionEnd );\n\t\treturn () =>\n\t\t\tcontainer?.removeEventListener( 'transitionend', onTransitionEnd );\n\t}, [ dataAttribute, container, transitionEndFilter ] );\n}\n/* eslint-enable jsdoc/require-param */\n"],"mappings":"AAAA;;AAEA;AACA;AACA;AACA,SAASA,QAAQ,QAAQ,oBAAoB;AAC7C,SAASC,eAAe,QAAQ,oBAAoB;AACpD;AACA;AACA;;AAEA,SAASC,gBAAgB,QAAQ,uBAAuB;;AAExD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,qBAAqBA;AACpC;AACD;AACA;AACCC,SAAkC;AAClC;AACD;AACA;AACCC,IAAuB,EACvB;EACCC,MAAM,GAAG,YAAY;EACrBC,aAAa,GAAG,GAAID,MAAM,WAAY;EACtCE,mBAAmB,GAAGA,CAAA,KAAM;AA2B7B,CAAC,GAAG,CAAC,CAAC,EACL;EACD,MAAMC,aAAa,GAAGT,QAAQ,CAAE,MAAM;IACnCU,MAAM,CAACC,IAAI,CAAEN,IAAK,CAAC,CAAiCO,OAAO,CAC1DC,QAAQ,IACTA,QAAQ,KAAK,SAAS,IACtBT,SAAS,EAAEU,KAAK,CAACC,WAAW,CAC3B,KAAMT,MAAM,IAAMO,QAAQ,EAAG,EAC7BG,MAAM,CAAEX,IAAI,CAAEQ,QAAQ,CAAG,CAC1B,CACF,CAAC;EACF,CAAE,CAAC;EACHZ,eAAe,CAAE,MAAM;IACtBQ,aAAa,CAAC,CAAC;EAChB,CAAC,EAAE,CAAEJ,IAAI,EAAEI,aAAa,CAAG,CAAC;EAC5BP,gBAAgB,CAAEG,IAAI,CAACY,OAAO,EAAE,CAAE;IAAEC;EAAc,CAAC,KAAM;IACxD;IACA,IAAKb,IAAI,CAACY,OAAO,IAAIC,aAAa,EAAG;MACpCd,SAAS,EAAEe,YAAY,CAAE,QAASZ,aAAa,EAAG,EAAE,EAAG,CAAC;IACzD;EACD,CAAE,CAAC;EACHN,eAAe,CAAE,MAAM;IACtB,SAASmB,eAAeA,CAAEC,KAAsB,EAAG;MAClD,IAAKb,mBAAmB,CAAEa,KAAM,CAAC,EAAG;QACnCjB,SAAS,EAAEkB,eAAe,CAAE,QAASf,aAAa,EAAI,CAAC;MACxD;IACD;IACAH,SAAS,EAAEmB,gBAAgB,CAAE,eAAe,EAAEH,eAAgB,CAAC;IAC/D,OAAO,MACNhB,SAAS,EAAEoB,mBAAmB,CAAE,eAAe,EAAEJ,eAAgB,CAAC;EACpE,CAAC,EAAE,CAAEb,aAAa,EAAEH,SAAS,EAAEI,mBAAmB,CAAG,CAAC;AACvD;AACA","ignoreList":[]}